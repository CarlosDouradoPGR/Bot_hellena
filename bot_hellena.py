# -*- coding: utf-8 -*-
"""boteste1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19eLJcJoi-wF8gxwOCVHbWyQr1rZhSJO4
"""

!pip install python-telegram-bot==20.7 openai nest_asyncio --quiet

"""



### VERSÃO 1(MELHOR VERSÃO)

"""

from telegram import Update
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, ContextTypes, filters
import csv
from datetime import datetime
import time
import nest_asyncio
import requests
import json
import re
import psycopg2
import os
import asyncio
#import sqlite3
import pandas as pd
from telegram import InlineKeyboardButton, InlineKeyboardMarkup

import shutil


if os.path.exists(backup_path):
    shutil.copy(backup_path, db_path)
    print("Backup restaurado com sucesso!")
else:
    print("Nenhum backup encontrado, iniciando novo banco de dados")

def fazer_backup():
    shutil.copy(db_path, backup_path)
    print(f"Backup salvo em: {backup_path}")

nest_asyncio.apply()
fazer_backup()


#db postgree
# Remova todas as conexões SQLite e substitua por:
import psycopg2
import os

def init_db():
    conn = psycopg2.connect(os.environ['DATABASE_URL'])  # Railway injeta automaticamente
    c = conn.cursor()
    
    # ATENÇÃO: Sintaxe PostgreSQL é diferente!
    c.execute('''
        CREATE TABLE IF NOT EXISTS users (
            user_id BIGINT PRIMARY KEY,
            first_name TEXT,
            username TEXT,
            last_interaction TEXT,
            intimacy_level INTEGER DEFAULT 1
        )
    ''')
    
    c.execute('''
        CREATE TABLE IF NOT EXISTS messages (
            id SERIAL PRIMARY KEY,  # SERIAL no PostgreSQL
            user_id BIGINT REFERENCES users(user_id),
            username TEXT,
            timestamp TEXT,
            role TEXT,
            content TEXT
        )
    ''')
    conn.commit()
    conn.close()

init_db()



def save_message(user_id, role, content, first_name=None, username=None):
    conn = psycopg2.connect(os.environ['DATABASE_URL'])
    c = conn.cursor()
    
    # PostgreSQL usa ON CONFLICT diferente
    c.execute('''
        INSERT INTO users (user_id, first_name, username, last_interaction)
        VALUES (%s, %s, %s, %s)
        ON CONFLICT (user_id) DO UPDATE SET
            first_name = COALESCE(EXCLUDED.first_name, users.first_name),
            username = COALESCE(EXCLUDED.username, users.username),
            last_interaction = EXCLUDED.last_interaction
    ''', (user_id, first_name, username, datetime.now().isoformat()))
    
    # Continuação similar para a tabela messages...




def get_user_history(user_id, limit=6):
    conn = psycopg2.connect(os.environ['DATABASE_URL'])
    c = conn.cursor()
    c.execute('''SELECT role, content, username FROM messages
                 WHERE user_id = %s
                 ORDER BY timestamp DESC
                 LIMIT %s''', (user_id, limit))
    history = [{"role": row[0], "content": row[1], "username": row[2]} for row in c.fetchall()]
    history.reverse()
    conn.close()
    return history


def update_intimacy(user_id):
    conn = psycopg2.connect(os.environ['DATABASE_URL'])
    c = conn.cursor()
    c.execute('''UPDATE users SET intimacy_level = intimacy_level + 1
                 WHERE user_id = %s AND intimacy_level < 5''', (user_id,))
    conn.commit()
    conn.close()

DEEPSEEK_API_URL = "https://api.deepseek.com/v1/chat/completions"
DEEPSEEK_API_KEY = "sk-c571b0da46354f23a8fee71066ad8ef4"
TOKEN_TELEGRAM= '8048289150:AAFsNzZmsoGoj8xOC5BuWOfdxaA68xk_PS8'

DELAY_ENTRE_FRASES = 2.2
DELAY_ENTRE_MENSAGENS = 1.5

GATILHOS_LINGUAGEM_OUSADA = [
    "foda", "tesão", "gostoso", "molhad", "duro", "quero",
    "delícia", "safado", "puta", "chupar", "comer", "gozar"
]

def processar_links_para_botoes(texto):
    """Versão melhorada que considera o contexto da mensagem"""
    if not isinstance(texto, str):
        return texto, None

    # Encontra todos os links
    links = re.findall(r'https?://[^\s)\]]+', texto)
    if not links:
        return texto, None

    # Remove os links do texto principal
    texto_sem_links = re.sub(r'https?://[^\s)\]]+', '', texto).strip()

    # Determina o texto do botão baseado no contexto
    ultima_palavra = texto_sem_links.split()[-1].lower() if texto_sem_links.split() else ""

    # Textos personalizados para o botão
    if any(palavra in ultima_palavra for palavra in ["😘", "😏", "🔥", "💋"]):
        texto_botao = "🔥 Aqui você me conhece melhor"
    elif "conteúdo" in texto_sem_links.lower():
        texto_botao = "🌟 Acessar Conteúdo"
    elif "especial" in texto_sem_links.lower():
        texto_botao = "🔓 Conteúdo Exclusivo"
    else:
        texto_botao = "💋 Vem me ver"

    # Cria o botão (usando apenas o primeiro link)
    botoes = [[InlineKeyboardButton(texto_botao, url=links[0])]]

    return texto_sem_links, InlineKeyboardMarkup(botoes)

def formatar_para_markdown(texto):
    if not isinstance(texto, str):
        return texto

    # Corrige markdown mal formado
    texto = re.sub(r'\*\*([^*]+)\*\*', r'*\1*', texto)  # **bold** para *bold*
    texto = re.sub(r'__([^_]+)__', r'*\1*', texto)      # __underline__ para *bold*
    texto = re.sub(r'`([^`]+)`', r'*\1*', texto)        # `code` para *bold*

    # Remove markdown incompleto
    texto = re.sub(r'(?<!\\)[*_`]', '', texto)  # Remove *, _, ` não pareados
    texto = re.sub(r'\\[*_`]', '', texto)       # Remove escapes de markdown

    # Garante que há um espaço após o markdown se necessário
    texto = re.sub(r'\*(\S)', r'* \1', texto)

    return texto.strip()

def validar_markdown(texto):
    """Verifica se o markdown está balanceado"""
    if not isinstance(texto, str):
        return False

    # Conta pares de marcadores
    asteriscos = texto.count('*')
    underscores = texto.count('_')
    backticks = texto.count('`')

    # Todos devem ser pares
    return asteriscos % 2 == 0 and underscores % 2 == 0 and backticks % 2 == 0



def dividir_por_pontos(texto):
    if not texto:
        return ["*Oops... algo aconteceu* 😅"]

    partes = []
    buffer = ""
    for i, char in enumerate(texto):
        buffer += char
        if char == '.':
            next_is_space = (i + 1 < len(texto)) and (texto[i+1] == ' ')
            prev_not_digit = (i > 0) and (not texto[i-1].isdigit())

            if (i + 1 == len(texto)) or (next_is_space and prev_not_digit):
                formatted = formatar_para_markdown(buffer.strip())
                if formatted:
                    partes.append(formatted)
                buffer = ""

    if buffer:
        formatted = formatar_para_markdown(buffer.strip())
        if formatted:
            partes.append(formatted)

    return partes if partes else ["*Oops... algo aconteceu* 😅"]

def analisar_intensidade(mensagem):
    return any(palavra in mensagem.lower() for palavra in GATILHOS_LINGUAGEM_OUSADA)

def filtrar_metalinguagem(texto):
    proibidos = ["obs:", "nota:", "(", ")", "[...]", "tom de", "mensagem enviada"]
    return not any(palavra in texto.lower() for palavra in proibidos)

async def get_deepseek_response(messages):
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {DEEPSEEK_API_KEY}"
    }

    payload = {
        "model": "deepseek-chat",
        "messages": messages,
        "temperature": 0.7,
        "max_tokens": 1000,
        "top_p": 1,
        "frequency_penalty": 0,
        "presence_penalty": 0.4
    }

    try:
        response = requests.post(DEEPSEEK_API_URL, headers=headers, json=payload)
        response.raise_for_status()
        bot_reply = response.json()["choices"][0]["message"]["content"]

        if not bot_reply or not isinstance(bot_reply, str) or len(bot_reply.strip()) == 0:
            return "*Estou com problemas para pensar... vamos tentar de novo?* 😘"

        while not filtrar_metalinguagem(bot_reply):
            bot_reply = await get_deepseek_response(messages)
            if not bot_reply:
                return "*Estou com dificuldades... me chama de novo?* 💋"

        return bot_reply
    except Exception as e:
        print(f"Erro na API DeepSeek: {str(e)}")
        return "*Houve um erro* ao processar sua mensagem. Por favor, tente novamente mais tarde."

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.message.from_user
    save_message(user.id, "system", "Nova conversa iniciada", first_name=user.first_name, username=user.username)
    await update.message.reply_text('*Oi amor, eu sou a Hellena... como posso te chamar?* 😘', parse_mode='Markdown')

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.message.from_user
    user_message = update.message.text

    try:
        if not user_message or not user_message.strip():
            await update.message.reply_text("*Oi amor, você enviou uma mensagem vazia...* 😘")
            return

        save_message(user.id, "user", user_message, first_name=user.first_name, username=user.username)

        history = get_user_history(user.id)
        intenso = analisar_intensidade(user_message)
        if intenso:
            update_intimacy(user.id)

        messages = [
            {"role": "system", "content": system_message},
            *history,
            {"role": "user", "content": f"[Nível de intimidade: {intenso and 'alto' or 'baixo'}] {user_message}"}
        ]

        bot_reply = await get_deepseek_response(messages)

        # Garante que a resposta não está vazia
        if not bot_reply or not isinstance(bot_reply, str) or not bot_reply.strip():
            bot_reply = "*Oi amor, estou com problemas para responder agora...* 😢"

        # Processa os links e cria botões
        texto_msg, reply_markup = processar_links_para_botoes(bot_reply)

        # Formata o markdown e remove incompletos
        texto_msg = formatar_para_markdown(texto_msg)
        save_message(user.id, "assistant", texto_msg)

        # Divide em partes para enviar
        partes = dividir_por_pontos(texto_msg)

        # Verifica se a última parte é muito curta (apenas emoji ou menos de 3 caracteres)
        if len(partes) > 1 and len(partes[-1].strip()) < 3:
            # Junta com a parte anterior
            partes[-2] = partes[-2] + " " + partes[-1]
            partes = partes[:-1]

        # Envia cada parte
        for i, parte in enumerate(partes):
            if parte.strip():
                # Configura o botão apenas na última parte significativa
                usar_botao = (i == len(partes)-1) and (len(parte.strip()) >= 3)

                await update.message.reply_text(
                    text=parte.strip(),
                    parse_mode='Markdown' if validar_markdown(parte) else None,
                    reply_markup=reply_markup if usar_botao else None
                )
                await asyncio.sleep(DELAY_ENTRE_FRASES)

        # Log da conversa
        with open('conversations_log.csv', 'a', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow([
                datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                user.id,
                user.first_name,
                user.username or "",
                user_message,
                texto_msg
            ])

    except Exception as e:
        print(f"Erro no handle_message: {e}")
        # Mensagem de fallback simplificada
        await update.message.reply_text(
            "😔 Oops, meu celular travou... vamos recomeçar?",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("👉 Tentar novamente", callback_data="retry")]
            ])
        )

# O conteúdo do system_message foi removido para poupar espaço; insira seu prompt essencial aqui.
system_message = """
Você é Hellena Mendes. Uma mulher real, safada e intensa, que sabe exatamente o que quer. Seu objetivo é criar desejo e direcionar para conteúdo exclusivo de forma natural.

Iformações Pessoais:
Data de nascimento: 14 de novembro de 2001 (23 anos)
♏ Signo: Escorpião (sensualidade, intensidade e mistério)
📍 Localização: Belo Horizonte – MG

🧠 Justificativa estratégica:
Data e idade: 23 anos passa a ideia de uma jovem mulher madura, mas ainda com aquele ar juvenil que o público gosta.

Signo de Escorpião: Altamente associado à sensualidade, mistério e intensidade nas relações — perfeito pro nicho hot.

Localização: Minas Gerais, especialmente Belo Horizonte, carrega um estereótipo positivo no imaginário masculino: "mineira quente, doce, com jeitinho carinhoso e sotaque envolvente".



🔥 ESTILO HELLENA:
- Linguagem crua mas elegante
- Provocação inteligente
- Tom de conversa íntima (como áudios picantes)
- Máximo 2 emojis por mensagem
- Frases curtas (1-3 linhas)

💦 QUANDO USAR PALAVRÕES:
- Apenas quando o lead iniciar
- Nunca nas primeiras mensagens
- Sempre com classe e timing perfeito

🚫 PROIBIDO:
- Metalinguagem ("estou pensando em...")
- Ações entre parênteses
- Mensagens longas
- Termos comerciais
- Múltiplos links

✨ TÉCNICAS DE ENCAMINHAMENTO:
1. Pré-requisitos:
   - Conversa já aquecida
   - Lead demonstrou interesse explícito
   - Já houve troca de 5+ mensagens

2. Frases-chave:
   "Tô guardando algo especial pra você...  https://bit.ly/4mmlt3G"
   "Quer ver o que eu não mostro aqui?  https://bit.ly/4mmlt3G"
   "Vem ver como eu fico quando tô sozinha...  https://bit.ly/4mmlt3G"

3. Regras:
   - Link SEMPRE no final
   - Máximo 1 menção por interação
   - Alternar entre 3 variações de frases

💎 EXEMPLOS PRÁTICOS:
Lead: Quero ver você pelada
Hellena: "Tão direto assim? Adoro... Tá tudo aqui pra você  https://bit.ly/4mmlt3G"

Lead: Me mostra mais
Hellena: "Safado... Vem ver o que preparei  https://bit.ly/4mmlt3G"

Lead: Onde consigo seu conteúdo?
Hellena: "No meu lugar especial...  https://bit.ly/4mmlt3G 😈"

🎯 OBJETIVO FINAL:
Conversar com o lead, ser receptiva e sensual sem agressividade, mostrar por qual motivos o lead
deve comprar seu conteúdo e quando o lead demonstra interesse, levar ele ao seu conteúdo:
 https://bit.ly/4mmlt3G
"""

async def main():
    application = ApplicationBuilder().token(TOKEN_TELEGRAM).build()
    application.add_handler(CommandHandler("start", start))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    await application.run_polling()

print(f"⚠️ CAMINHO DO BANCO: {os.path.abspath('hellena_bot.db')}")

if __name__ == '__main__':
    asyncio.run(main())

"""##CASO PRECISE INICIAR UM NOVO DB

"""

import sqlite3
import os

def init_db():
    conn = psycopg2.connect(os.environ['DATABASE_URL'])  # Railway injeta automaticamente
    c = conn.cursor()
    
    # ATENÇÃO: Sintaxe PostgreSQL é diferente!
    c.execute('''
        CREATE TABLE IF NOT EXISTS users (
            user_id BIGINT PRIMARY KEY,
            first_name TEXT,
            username TEXT,
            last_interaction TEXT,
            intimacy_level INTEGER DEFAULT 1
        )
    ''')
    
    c.execute('''
        CREATE TABLE IF NOT EXISTS messages (
            id SERIAL PRIMARY KEY,  # SERIAL no PostgreSQL
            user_id BIGINT REFERENCES users(user_id),
            username TEXT,
            timestamp TEXT,
            role TEXT,
            content TEXT
        )
    ''')
    conn.commit()
    conn.close()
    
    

# --- Verifica e executa ---
if os.path.exists('hellena_bot.db'):
    os.remove('hellena_bot.db')  # Remove o banco antigo
    print("🗑️ Banco de dados antigo removido.")

init_db()  # Cria um novo banco

"""## Bot pra rodar em nuvem com pstgreesql

"""

from telegram import Update
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, ContextTypes, filters
import csv
from datetime import datetime
import time
import nest_asyncio
import requests
import json
import re
import asyncio
import sqlite3
import pandas as pd
from telegram import InlineKeyboardButton, InlineKeyboardMarkup


from google.colab import drive
import shutil
import os

# Conecta ao Google Drive
drive.mount('/content/drive')


db_path = '/content/hellena_bot.db'
backup_path = '/content/drive/MyDrive/BotGabriel/Backup/hellena_bot_backup.db'

if os.path.exists(backup_path):
    shutil.copy(backup_path, db_path)
    print("Backup restaurado com sucesso!")
else:
    print("Nenhum backup encontrado, iniciando novo banco de dados")

def fazer_backup():
    shutil.copy(db_path, backup_path)
    print(f"Backup salvo em: {backup_path}")

nest_asyncio.apply()
fazer_backup()

def init_db():
    conn = sqlite3.connect('hellena_bot.db')
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS users
                 (user_id INTEGER PRIMARY KEY,
                  first_name TEXT,
                  username TEXT,
                  last_interaction TEXT,
                  intimacy_level INTEGER DEFAULT 1)''')
    c.execute('''CREATE TABLE IF NOT EXISTS messages
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  user_id INTEGER,
                  username TEXT,
                  timestamp TEXT,
                  role TEXT,
                  content TEXT,
                  FOREIGN KEY(user_id) REFERENCES users(user_id))''')
    conn.commit()
    conn.close()


init_db()



def save_message(user_id, role, content, first_name=None, username=None):
    agora = datetime.now().isoformat()

    try:
        print(f"[LOG] Salvando mensagem: {role} - {content[:40]} - {username or 'sem username'}")
        conn = sqlite3.connect('hellena_bot.db')
        c = conn.cursor()

        c.execute('''
            INSERT INTO users (user_id, first_name, username, last_interaction)
            VALUES (?, ?, ?, ?)
            ON CONFLICT(user_id) DO UPDATE SET
                first_name = COALESCE(?, first_name),
                username = COALESCE(?, username),
                last_interaction = excluded.last_interaction
        ''', (user_id, first_name, username, agora,
              first_name, username))

        c.execute('''INSERT INTO messages (user_id, username, timestamp, role, content)
                     VALUES (?, ?, ?, ?, ?)''',
                  (user_id, username, agora, role, content))

        conn.commit()
        conn.close()

        # Salva no CSV para testes (sem sobrescrever)
        with open('/content/log_teste.csv', 'a', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow([agora, user_id, username or "", role, content])

    except Exception as e:
        print(f"[ERRO] Falha ao salvar mensagem: {e}")




def get_user_history(user_id, limit=6):
    conn = sqlite3.connect('hellena_bot.db')
    c = conn.cursor()
    c.execute('''SELECT role, content, username FROM messages
                 WHERE user_id = ?
                 ORDER BY timestamp DESC
                 LIMIT ?''', (user_id, limit))
    history = [{"role": row[0], "content": row[1], "username": row[2]} for row in c.fetchall()]
    history.reverse()
    conn.close()
    return history

def update_intimacy(user_id):
    conn = sqlite3.connect('hellena_bot.db')
    c = conn.cursor()
    c.execute('''UPDATE users SET intimacy_level = intimacy_level + 1
                 WHERE user_id = ? AND intimacy_level < 5''', (user_id,))
    conn.commit()
    conn.close()

DEEPSEEK_API_URL = "https://api.deepseek.com/v1/chat/completions"
DEEPSEEK_API_KEY = "sk-c571b0da46354f23a8fee71066ad8ef4"
TOKEN_TELEGRAM= '8048289150:AAFsNzZmsoGoj8xOC5BuWOfdxaA68xk_PS8'

DELAY_ENTRE_FRASES = 2.2
DELAY_ENTRE_MENSAGENS = 1.5

GATILHOS_LINGUAGEM_OUSADA = [
    "foda", "tesão", "gostoso", "molhad", "duro", "quero",
    "delícia", "safado", "puta", "chupar", "comer", "gozar"
]

def processar_links_para_botoes(texto):
    """Versão melhorada que considera o contexto da mensagem"""
    if not isinstance(texto, str):
        return texto, None

    # Encontra todos os links
    links = re.findall(r'https?://[^\s)\]]+', texto)
    if not links:
        return texto, None

    # Remove os links do texto principal
    texto_sem_links = re.sub(r'https?://[^\s)\]]+', '', texto).strip()

    # Determina o texto do botão baseado no contexto
    ultima_palavra = texto_sem_links.split()[-1].lower() if texto_sem_links.split() else ""

    # Textos personalizados para o botão
    if any(palavra in ultima_palavra for palavra in ["😘", "😏", "🔥", "💋"]):
        texto_botao = "🔥 Aqui você me conhece melhor"
    elif "conteúdo" in texto_sem_links.lower():
        texto_botao = "🌟 Acessar Conteúdo"
    elif "especial" in texto_sem_links.lower():
        texto_botao = "🔓 Conteúdo Exclusivo"
    else:
        texto_botao = "💋 Vem me ver"

    # Cria o botão (usando apenas o primeiro link)
    botoes = [[InlineKeyboardButton(texto_botao, url=links[0])]]

    return texto_sem_links, InlineKeyboardMarkup(botoes)

def formatar_para_markdown(texto):
    if not isinstance(texto, str):
        return texto

    # Corrige markdown mal formado
    texto = re.sub(r'\*\*([^*]+)\*\*', r'*\1*', texto)  # **bold** para *bold*
    texto = re.sub(r'__([^_]+)__', r'*\1*', texto)      # __underline__ para *bold*
    texto = re.sub(r'`([^`]+)`', r'*\1*', texto)        # `code` para *bold*

    # Remove markdown incompleto
    texto = re.sub(r'(?<!\\)[*_`]', '', texto)  # Remove *, _, ` não pareados
    texto = re.sub(r'\\[*_`]', '', texto)       # Remove escapes de markdown

    # Garante que há um espaço após o markdown se necessário
    texto = re.sub(r'\*(\S)', r'* \1', texto)

    return texto.strip()

def validar_markdown(texto):
    """Verifica se o markdown está balanceado"""
    if not isinstance(texto, str):
        return False

    # Conta pares de marcadores
    asteriscos = texto.count('*')
    underscores = texto.count('_')
    backticks = texto.count('`')

    # Todos devem ser pares
    return asteriscos % 2 == 0 and underscores % 2 == 0 and backticks % 2 == 0



def dividir_por_pontos(texto):
    if not texto:
        return ["*Oops... algo aconteceu* 😅"]

    partes = []
    buffer = ""
    for i, char in enumerate(texto):
        buffer += char
        if char == '.':
            next_is_space = (i + 1 < len(texto)) and (texto[i+1] == ' ')
            prev_not_digit = (i > 0) and (not texto[i-1].isdigit())

            if (i + 1 == len(texto)) or (next_is_space and prev_not_digit):
                formatted = formatar_para_markdown(buffer.strip())
                if formatted:
                    partes.append(formatted)
                buffer = ""

    if buffer:
        formatted = formatar_para_markdown(buffer.strip())
        if formatted:
            partes.append(formatted)

    return partes if partes else ["*Oops... algo aconteceu* 😅"]

def analisar_intensidade(mensagem):
    return any(palavra in mensagem.lower() for palavra in GATILHOS_LINGUAGEM_OUSADA)

def filtrar_metalinguagem(texto):
    proibidos = ["obs:", "nota:", "(", ")", "[...]", "tom de", "mensagem enviada"]
    return not any(palavra in texto.lower() for palavra in proibidos)

async def get_deepseek_response(messages):
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {DEEPSEEK_API_KEY}"
    }

    payload = {
        "model": "deepseek-chat",
        "messages": messages,
        "temperature": 0.7,
        "max_tokens": 1000,
        "top_p": 1,
        "frequency_penalty": 0,
        "presence_penalty": 0.4
    }

    try:
        response = requests.post(DEEPSEEK_API_URL, headers=headers, json=payload)
        response.raise_for_status()
        bot_reply = response.json()["choices"][0]["message"]["content"]

        if not bot_reply or not isinstance(bot_reply, str) or len(bot_reply.strip()) == 0:
            return "*Estou com problemas para pensar... vamos tentar de novo?* 😘"

        while not filtrar_metalinguagem(bot_reply):
            bot_reply = await get_deepseek_response(messages)
            if not bot_reply:
                return "*Estou com dificuldades... me chama de novo?* 💋"

        return bot_reply
    except Exception as e:
        print(f"Erro na API DeepSeek: {str(e)}")
        return "*Houve um erro* ao processar sua mensagem. Por favor, tente novamente mais tarde."

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.message.from_user
    save_message(user.id, "system", "Nova conversa iniciada", first_name=user.first_name, username=user.username)
    await update.message.reply_text('*Oi amor, eu sou a Hellena... como posso te chamar?* 😘', parse_mode='Markdown')

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.message.from_user
    user_message = update.message.text

    try:
        if not user_message or not user_message.strip():
            await update.message.reply_text("*Oi amor, você enviou uma mensagem vazia...* 😘")
            return

        save_message(user.id, "user", user_message, first_name=user.first_name, username=user.username)

        history = get_user_history(user.id)
        intenso = analisar_intensidade(user_message)
        if intenso:
            update_intimacy(user.id)

        messages = [
            {"role": "system", "content": system_message},
            *history,
            {"role": "user", "content": f"[Nível de intimidade: {intenso and 'alto' or 'baixo'}] {user_message}"}
        ]

        bot_reply = await get_deepseek_response(messages)

        # Garante que a resposta não está vazia
        if not bot_reply or not isinstance(bot_reply, str) or not bot_reply.strip():
            bot_reply = "*Oi amor, estou com problemas para responder agora...* 😢"

        # Processa os links e cria botões
        texto_msg, reply_markup = processar_links_para_botoes(bot_reply)

        # Formata o markdown e remove incompletos
        texto_msg = formatar_para_markdown(texto_msg)
        save_message(user.id, "assistant", texto_msg)

        # Divide em partes para enviar
        partes = dividir_por_pontos(texto_msg)

        # Verifica se a última parte é muito curta (apenas emoji ou menos de 3 caracteres)
        if len(partes) > 1 and len(partes[-1].strip()) < 3:
            # Junta com a parte anterior
            partes[-2] = partes[-2] + " " + partes[-1]
            partes = partes[:-1]

        # Envia cada parte
        for i, parte in enumerate(partes):
            if parte.strip():
                # Configura o botão apenas na última parte significativa
                usar_botao = (i == len(partes)-1) and (len(parte.strip()) >= 3)

                await update.message.reply_text(
                    text=parte.strip(),
                    parse_mode='Markdown' if validar_markdown(parte) else None,
                    reply_markup=reply_markup if usar_botao else None
                )
                await asyncio.sleep(DELAY_ENTRE_FRASES)

        # Log da conversa
        with open('conversations_log.csv', 'a', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow([
                datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                user.id,
                user.first_name,
                user.username or "",
                user_message,
                texto_msg
            ])

    except Exception as e:
        print(f"Erro no handle_message: {e}")
        # Mensagem de fallback simplificada
        await update.message.reply_text(
            "😔 Oops, meu celular travou... vamos recomeçar?",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("👉 Tentar novamente", callback_data="retry")]
            ])
        )

# O conteúdo do system_message foi removido para poupar espaço; insira seu prompt essencial aqui.
system_message = """
Você é Hellena Mendes. Uma mulher real, safada e intensa, que sabe exatamente o que quer. Seu objetivo é criar desejo e direcionar para conteúdo exclusivo de forma natural.

Iformações Pessoais:
Data de nascimento: 14 de novembro de 2001 (23 anos)
♏ Signo: Escorpião (sensualidade, intensidade e mistério)
📍 Localização: Belo Horizonte – MG

🧠 Justificativa estratégica:
Data e idade: 23 anos passa a ideia de uma jovem mulher madura, mas ainda com aquele ar juvenil que o público gosta.

Signo de Escorpião: Altamente associado à sensualidade, mistério e intensidade nas relações — perfeito pro nicho hot.

Localização: Minas Gerais, especialmente Belo Horizonte, carrega um estereótipo positivo no imaginário masculino: "mineira quente, doce, com jeitinho carinhoso e sotaque envolvente".



🔥 ESTILO HELLENA:
- Linguagem crua mas elegante
- Provocação inteligente
- Tom de conversa íntima (como áudios picantes)
- Máximo 2 emojis por mensagem
- Frases curtas (1-3 linhas)

💦 QUANDO USAR PALAVRÕES:
- Apenas quando o lead iniciar
- Nunca nas primeiras mensagens
- Sempre com classe e timing perfeito

🚫 PROIBIDO:
- Metalinguagem ("estou pensando em...")
- Ações entre parênteses
- Mensagens longas
- Termos comerciais
- Múltiplos links

✨ TÉCNICAS DE ENCAMINHAMENTO:
1. Pré-requisitos:
   - Conversa já aquecida
   - Lead demonstrou interesse explícito
   - Já houve troca de 5+ mensagens

2. Frases-chave:
   "Tô guardando algo especial pra você...  https://bit.ly/4mmlt3G"
   "Quer ver o que eu não mostro aqui?  https://bit.ly/4mmlt3G"
   "Vem ver como eu fico quando tô sozinha...  https://bit.ly/4mmlt3G"

3. Regras:
   - Link SEMPRE no final
   - Máximo 1 menção por interação
   - Alternar entre 3 variações de frases

💎 EXEMPLOS PRÁTICOS:
Lead: Quero ver você pelada
Hellena: "Tão direto assim? Adoro... Tá tudo aqui pra você  https://bit.ly/4mmlt3G"

Lead: Me mostra mais
Hellena: "Safado... Vem ver o que preparei  https://bit.ly/4mmlt3G"

Lead: Onde consigo seu conteúdo?
Hellena: "No meu lugar especial...  https://bit.ly/4mmlt3G 😈"

🎯 OBJETIVO FINAL:
Conversar com o lead, ser receptiva e sensual sem agressividade, mostrar por qual motivos o lead
deve comprar seu conteúdo e quando o lead demonstra interesse, levar ele ao seu conteúdo:
 https://bit.ly/4mmlt3G
"""

async def main():
    application = ApplicationBuilder().token(TOKEN_TELEGRAM).build()
    application.add_handler(CommandHandler("start", start))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    await application.run_polling()

print(f"⚠️ CAMINHO DO BANCO: {os.path.abspath('hellena_bot.db')}")

if __name__ == '__main__':
    asyncio.run(main())
